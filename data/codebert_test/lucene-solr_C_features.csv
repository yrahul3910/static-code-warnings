canonical_id,F72,F54,F55,F25,F26,F62,F65,F64,F67,F34,F66,F69,F68,F101,F102,F103,F104,F105,F107,F108,F16-float,F16-SegmentInfoWriter,F16-DocData,F16-char[],F16-long,F16-Object,F16-NA,F16-void,F16-int,F16-DocsAndPositionsEnum,F16-Query,F16-Iterator<BytesRef>,F16-boolean,F16-FieldInfosWriter,F16-Collection<ContentStream>,F16-String,F16-Iterator<String>,F16-NamedList,F16-Void,F16-BytesRef,F3-BytesRef,F3-NA,F3-CharSequence,F3-int[],F3-Class,F3-Among[],F3-byte[],F3-boolean,F3-FileInputStream,F3-char,F3-Bits,F3-String,F3-long,F3-SolrParams,F3-CharStream,F3-int,F3-ValueSource,F3-char[],F3-getBoost(),F3-OutputStream,F7-|,F7-^,F7-++,F7-%,F7-&,F7-*,F7-+,F7-^=,F7--,F7-/,F7--=,F7-+=,F7-NA,F12-long,F12-int,F12-BytesRef,F12-NA,F12-boolean,F12-Map<String Req>,F12-Logger,F12-String[],F12-NamedList,F12-String,F12-Scorer,F12-List<String>,F12-byte,F12-Token,F12-float,F12-ValueSource,F12-QParser,F12-IndexInput,F12-SolrParams,F12-List<AnalysisPhase>,F17-abstract,F17-final-final-final,F17-static,F17-final,F17-static-final,F17-NA,F2-StringBuilder,F2-HungarianStemmer,F2-Class,F2-StandardSyntaxParser,F2-NA,F2-QueryParserTokenManager,F2-Integer,F2-List<String>,F2-InputStream,F2-QueryParser,F2-Object,F2-CharSequence,F2-String,F2-PorterStemmer,F2-BufferedReader,F2-Long,F2-System,F2-Float,F2-File,F2-HTMLStripCharFilter,F6-NA,F6-java.lang.Long,F6-java.util.HashSet<java.lang.String>,F6-org.apache.lucene.queryparser.surround.parser.Token,F6-java.io.FileOutputStream,F6-java.io.InputStreamReader,F6-java.io.FileInputStream,F6-java.util.Properties,F6-org.egothor.stemmer.Trie.StrEnum,F6-java.lang.UnsupportedOperationException,F6-org.apache.solr.parser.Token,F6-org.apache.lucene.codecs.simpletext.AlreadyClosedException,F6-java.lang.Character,F6-java.util.ArrayList<java.lang.String>,F6-java.io.File,F6-org.apache.solr.update.FSDataFastInputStream,F6-org.apache.solr.uima.processor.JCasPool,F6-java.lang.Double,F6-org.apache.solr.client.solrj.impl.BasicHeader,F6-java.io.BufferedReader,F13-private,F13-NA,F13-protected,F13-public,F18-protected,F18-private,F18-NA,F18-public,F14-static-final,F14-static,F14-NA,F14-final,F1-size,F1-NA,F1-add,F1-jj_ntk,F1-r_mark_regions,F1-getClass,F1-clone,F1-jj_consume_token,F1-iterator,F1-find_among_b,F1-get,F1-equals,F1-compareTo,F1-slice_from,F1-charAt,F1-zzUnpackTrans,F1-read,F1-getName,F1-toString,F1-length,F5-java.util.AbstractMap,F5-java.lang.Object,F5-SolrQueryRequestBase,F5-NA,F5-java.io.Writer,F5-BlockReader,F5-java.util.AbstractSequentialList,F5-java.util.Hashtable,F5-java.io.InputStream,F5-DocsAndPositionsEnum,F5-FastInputStream,F5-java.lang.Number,F5-java.lang.Throwable,F5-java.util.AbstractList,F5-java.lang.RuntimeException,F5-java.io.Reader,F5-java.io.OutputStream,F5-TermVectorsReader,F5-java.util.AbstractSet,F5-java.util.HashMap,F9-textFieldNames,F9-shardName,F9-a,F9-functions,F9-lo,F9-dateFormat,F9-reader,F9-scorer,F9-field,F9-map,F9-indexedField,F9-hi,F9-numDeadServersToTry,F9-expirationThresholdMilllis,F9-min,F9-source,F9-NA,F9-aliasedCollections,F9-sources,F9-length,F10-NA,F10-true,F19-NA,F19-abstract,F15-NA,F15-private,F15-protected,F15-public,F0-NA,F4-NA,F4-Integer,F4-boolean,F4-File[],F4-long,F4-QueryNode,F4-char,F4-Token,F4-Object,F4-SrndQuery,F4-Pattern,F4-void,F4-StringBuilder,F4-T,F4-int,F4-String,F4-Class,F4-Iterator,F4-Row,F4-DocsEnum,F8-DocumentsWriterFlushControl,F8-LocalReplicator,F8-TernaryTree,F8-DateFormatCacheKey,F8-CreateAlias,F8-RangeFacetRequest,F8-CollectionShardAdminRequest,F8-InputWindowToken,F8-EnumWithSlice,F8-Correction,F8-CombineSuggestionWrapper,F8-CurrentLevel,F8-RouteException,F8-TVTerms,F8-NA,F8-ElevationObj,F8-Frame,F8-JavaUtilRegexMatcher,F8-Block,F8-Req,F11-scorer,F11-fields,F11-NA,F11-collection,F11-inStart,F11-failedPings,F11-field,F11-routes,F11-b,F11-_fields,F11-start,F11-token,F11-routeResponses,F11-in,F11-vs,F11-_name,F11-clauses,F11-query,F11-state,F11-queryPhases,F94,F95,F21,F109,F20,F23,F22,F79,F111,F112,F113,F116,F117,F118,F119,F120,F110,F121,F122,F123,F114,F115,F61,F77,F88,F70,F41,F40,F43,F42,F45,F44,F46,F126,F127,F128,F129,F36,F130,F35,F131,F38,F132,F37,F133,F134,F39,F135,F136,F137,F83,F71-ryan@apache.org,F71-han@apache.org,F71-chrism@apache.org,F71-shalin@apache.org,F71-rmuir@apache.org,F71-simonw@apache.org,F71-sarowe@apache.org,F71-gsingers@apache.org,F71-hossman@apache.org,F71-ehatcher@apache.org,F71-buschmi@apache.org,F71-jpountz@apache.org,F71-markrmiller@apache.org,F71-noble@apache.org,F71-yonik@apache.org,F71-mikemccand@apache.org,F71-shaie@apache.org,F71-erick@apache.org,F71-dweiss@apache.org,F71-uschindler@apache.org,F74,F73,F84,url,method_name,F146,category,method_content
lucene-solr-C-75,13360,org/apache/lucene/analysis/cn/smart/hhmm,org/apache/lucene/analysis/cn/smart/hhmm/WordDictionary.java,623,True,18,19,900,1,6,64,1,10,0.275047258979206,334,143,0.4281437125748503,0.1944444444444444,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,8,EXPERIMENTAL,0.0040310970342643,OBL_UNSATISFIED_OBLIGATION,20,2,1,0.0049916805324459,0.002218524681087,0.00027731558513588466,-1.0,0.1818181818181818,0.0743801652892562,0.1428571428571428,0.0031323036888899,-0.6363636363636364,0.0,0.0007727975270479134,0.0031323036888899,-1.0,-1.0,19,12976,1692,20834,0,0.0,0,0,0,0,0.0,0,0,0,0,0,0,0,0.0,0,0,0,0,0,0,0,0,0.0,3707,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,11519,26424,2991,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//lucene/analysis/smartcn/src/java/org/apache/lucene/analysis/cn/smart/hhmm/WordDictionary.java,loadFromObj,10803,open,"private boolean loadFromObj(File serialObj) {
    try {
      loadFromObjectInputStream(new FileInputStream(serialObj));
      return true;
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }"
lucene-solr-C-758,12763,org/apache/lucene/index,org/apache/lucene/index/FieldInfos.java,568,True,0,12,21004,3,0,1917,1,387,0.5659824046920822,204,94,0.4607843137254901,1.0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,170,1,STYLE,0.0296573567520875,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,18,2,1,0.0471436494731003,0.00027731558513588466,0.00027731558513588466,0.0,0.1686746987951807,0.0037898255346361,0.1389114541023558,0.3314796054467413,-0.6265060240963856,0.0,0.0660741885625966,0.3314796054467413,-0.5671641791044776,0.0,11,3130,403,10988,2373,0.0,32,535,1838,2940,0.0155045709866944,0,0,0,0,0,0,0,0.0,0,0,0,0,0,0,0,0,0.0,676,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,8488,18807,44,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//lucene/core/src/java/org/apache/lucene/index/FieldInfos.java,addOrGet,7856,close,"synchronized int addOrGet(String fieldName, int preferredFieldNumber, DocValuesType dvType) {
      if (dvType != null) {
        DocValuesType currentDVType = docValuesType.get(fieldName);
        if (currentDVType == null) {
          docValuesType.put(fieldName, dvType);
        } else if (currentDVType != null && currentDVType != dvType) {
          throw new IllegalArgumentException(""cannot change DocValues type from "" + currentDVType + "" to "" + dvType + "" for field \"""" + fieldName + ""\"""");
        }
      }
      Integer fieldNumber = nameToNumber.get(fieldName);
      if (fieldNumber == null) {
        final Integer preferredBoxed = Integer.valueOf(preferredFieldNumber);

        if (preferredFieldNumber != -1 && !numberToName.containsKey(preferredBoxed)) {
          // cool - we can use this number globally
          fieldNumber = preferredBoxed;
        } else {
          // find a new FieldNumber
          while (numberToName.containsKey(++lowestUnassignedFieldNumber)) {
            // might not be up to date - lets do the work once needed
          }
          fieldNumber = lowestUnassignedFieldNumber;
        }
        
        numberToName.put(fieldNumber, fieldName);
        nameToNumber.put(fieldName, fieldNumber);
      }

      return fieldNumber.intValue();
    }"
lucene-solr-C-759,12763,org/apache/lucene/index,org/apache/lucene/index/FilteredTermsEnum.java,568,True,2,18,21004,3,0,1917,1,387,0.9367588932806324,115,111,0.9652173913043478,1.0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,170,1,STYLE,0.0034552260293694,SF_SWITCH_FALLTHROUGH,17,2,1,0.0471436494731003,0.00027731558513588466,0.00027731558513588466,-1.0,0.0,0.0,0.1389114541023558,0.3314796054467413,-1.0,0.0,0.0660741885625966,0.3314796054467413,-0.5671641791044776,-1.0,14,7544,837,15402,2373,0.0,32,535,1838,2940,0.0155045709866944,0,0,0,0,0,0,0,0.0,0,0,0,0,0,0,0,0,0.0,646,0,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,8458,26424,44,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//lucene/core/src/java/org/apache/lucene/index/FilteredTermsEnum.java,next,7856,open,"@SuppressWarnings(""fallthrough"")
  @Override
  public BytesRef next() throws IOException {
    //System.out.println(""FTE.next doSeek="" + doSeek);
    //new Throwable().printStackTrace(System.out);
    for (;;) {
      // Seek or forward the iterator
      if (doSeek) {
        doSeek = false;
        final BytesRef t = nextSeekTerm(actualTerm);
        //System.out.println(""  seek to t="" + (t == null ? ""null"" : t.utf8ToString()) + "" tenum="" + tenum);
        // Make sure we always seek forward:
        assert actualTerm == null || t == null || t.compareTo(actualTerm) > 0: ""curTerm="" + actualTerm + "" seekTerm="" + t;
        if (t == null || tenum.seekCeil(t) == SeekStatus.END) {
          // no more terms to seek to or enum exhausted
          //System.out.println(""  return null"");
          return null;
        }
        actualTerm = tenum.term();
        //System.out.println(""  got term="" + actualTerm.utf8ToString());
      } else {
        actualTerm = tenum.next();
        if (actualTerm == null) {
          // enum exhausted
          return null;
        }
      }
      
      // check if term is accepted
      switch (accept(actualTerm)) {
        case YES_AND_SEEK:
          doSeek = true;
          // term accepted, but we need to seek so fall-through
        case YES:
          // term accepted
          return actualTerm;
        case NO_AND_SEEK:
          // invalid term, seek next time
          doSeek = true;
          break;
        case END:
          // we are supposed to end the enum
          return null;
      }
    }
  }"
lucene-solr-C-1218,12891,org/apache/lucene/search/join,org/apache/lucene/search/join/TermsWithScoreCollector.java,581,True,0,6,1153,6,0,67,1,35,0.4486692015209125,198,25,0.1262626262626262,1.0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,4,STYLE,0.0397350993377483,SF_SWITCH_NO_DEFAULT,19,2,4,0.0024958402662229,0.0011092623405435,0.0011092623405435,0.0,0.0081967213114754,0.0002197171640869572,0.1389114541023558,0.3314796054467413,-0.9836065573770492,0.0,0.0660741885625966,0.3314796054467413,0.0,0.0,5,5033,581,12891,0,0.0,0,0,0,0,0.0,0,0,0,0,0,0,0,0.0,0,0,0,0,0,0,0,0,0.0,814,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,8626,26424,581,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//lucene/join/src/java/org/apache/lucene/search/join/TermsWithScoreCollector.java,collect,8393,close,"@Override
    public void collect(int doc) throws IOException {
      fromDocTerms.get(doc, spare);
      int ord = collectedTerms.add(spare);
      if (ord < 0) {
        ord = -ord - 1;
      } else {
        if (ord >= scoreSums.length) {
          scoreSums = ArrayUtil.grow(scoreSums);
        }
      }

      float current = scorer.score();
      float existing = scoreSums[ord];
      if (Float.compare(existing, 0.0f) == 0) {
        scoreSums[ord] = current;
      } else {
        switch (scoreMode) {
          case Total:
            scoreSums[ord] = scoreSums[ord] + current;
            break;
          case Max:
            if (current > existing) {
              scoreSums[ord] = current;
            }
        }
      }
    }"
lucene-solr-C-1226,10522,org/apache/lucene/search/postingshighlight,org/apache/lucene/search/postingshighlight/Passage.java,360,True,3,10,569,2,4,47,1,13,0.93125,83,59,0.7108433734939759,0.6666666666666666,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,4,MALICIOUS_CODE,0.0169881946443996,EI_EXPOSE_REP,18,2,1,0.0030504714364947,0.0011092623405435,0.00027731558513588466,0.0,0.2222222222222222,0.0172839506172839,0.0838926174496644,0.010797874616244,-0.5185185185185185,0.0,0.0096599690880989,0.010797874616244,0.0,0.0,6,2664,360,10522,1,0.0,0,1,0,2,0.0222222222222222,0,0,0,0,0,0,0,0.0,0,0,0,0,0,0,0,0,0.0,1506,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,9318,26424,478,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//lucene/highlighter/src/java/org/apache/lucene/search/postingshighlight/Passage.java,getMatchEnds,8290,open,"public int[] getMatchEnds() {
    return matchEnds;
  }"
lucene-solr-C-1227,10522,org/apache/lucene/search/postingshighlight,org/apache/lucene/search/postingshighlight/Passage.java,360,True,3,10,569,2,4,47,1,13,0.8625,83,59,0.7108433734939759,0.6666666666666666,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,4,MALICIOUS_CODE,0.0169881946443996,EI_EXPOSE_REP,18,2,1,0.0030504714364947,0.0011092623405435,0.00027731558513588466,0.0,0.2222222222222222,0.0172839506172839,0.0838926174496644,0.010797874616244,-0.5185185185185185,0.0,0.0096599690880989,0.010797874616244,0.0,0.0,6,2664,360,10522,1,0.0,0,1,0,2,0.0222222222222222,0,0,0,0,0,0,0,0.0,0,0,0,0,0,0,0,0,0.0,1506,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,9318,26424,478,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//lucene/highlighter/src/java/org/apache/lucene/search/postingshighlight/Passage.java,getMatchTerms,8290,open,"public BytesRef[] getMatchTerms() {
    return matchTerms;
  }"
lucene-solr-C-1255,14304,org/apache/lucene/search/spans,org/apache/lucene/search/spans/SpanFirstQuery.java,693,True,5,6,1508,1,4,171,1,34,0.7222222222222222,51,25,0.4901960784313725,0.6,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,3,BAD_PRACTICE,0.0054707745465015,CN_IDIOM_NO_SUPER_CALL,16,2,1,0.0074875207986688,0.0008319467554076539,0.00027731558513588466,-1.0,0.0,0.0,0.0655021834061135,0.2740285622945125,-0.9285714285714286,0.0,0.0115919629057187,0.2740285622945125,-0.9310344827586208,-1.0,14,12646,1640,20504,0,0.0,0,0,0,0,0.0,0,0,0,0,0,0,0,0.0,0,0,0,0,0,0,0,0,0.0,4951,1,0,0,0,1,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,12763,26424,924,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//lucene/core/src/java/org/apache/lucene/search/spans/SpanFirstQuery.java,clone,8736,close,"@Override
  public SpanFirstQuery clone() {
    SpanFirstQuery spanFirstQuery = new SpanFirstQuery((SpanQuery) match.clone(), end);
    spanFirstQuery.setBoost(getBoost());
    return spanFirstQuery;
  }"
lucene-solr-C-1299,14953,org/apache/lucene/search/suggest/fst,org/apache/lucene/search/suggest/fst/ExternalRefSorter.java,761,True,18,6,545,2,6,48,5,10,0.6578947368421053,87,30,0.3448275862068966,0.3611111111111111,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,3,BAD_PRACTICE,0.0132450331125827,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,16,2,1,0.002218524681087,0.0008319467554076539,0.00027731558513588466,-1.0,0.1739130434782608,0.0038828999131456,0.0655021834061135,0.2740285622945125,-0.6521739130434783,0.0,0.0115919629057187,0.2740285622945125,-0.3333333333333333,-1.0,8,7095,761,14953,22,0.0,0,14,8,36,0.0092396762715365,0,0,0,0,0,0,0,0.0,0,0,0,0,0,0,0,0,0.0,646,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,8458,2505,365,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/ExternalRefSorter.java,close,8177,close,"@Override
  public void close() throws IOException {
    try {
      closeWriter();
    } finally {
      if (input != null) input.delete();
      if (sorted != null) sorted.delete();
    }
  }"
lucene-solr-C-1301,14953,org/apache/lucene/search/suggest/fst,org/apache/lucene/search/suggest/fst/FSTCompletion.java,761,True,0,13,545,2,0,48,1,10,0.1544117647058823,189,182,0.9629629629629628,1.0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,1,BAD_PRACTICE,0.0063345810538439,EQ_COMPARETO_USE_OBJECT_EQUALS,16,2,1,0.002218524681087,0.00027731558513588466,0.00027731558513588466,-1.0,0.3125,0.0058065878378378,0.0655021834061135,0.2740285622945125,-0.375,0.0,0.0115919629057187,0.2740285622945125,-0.3333333333333333,-1.0,12,7095,761,14953,22,0.0,0,14,8,36,0.0092396762715365,0,0,0,0,0,0,0,0.0,0,0,0,0,0,0,0,0,0.0,2607,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,1,1,10419,26424,365,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletion.java,compareTo,8177,open,"@Override
    public int compareTo(Completion o) {
      return this.utf8.compareTo(o.utf8);
    }"
lucene-solr-C-1304,12763,org/apache/lucene/search/suggest/fst,org/apache/lucene/search/suggest/fst/WFSTCompletionLookup.java,568,True,24,11,545,3,4,48,5,10,0.3344594594594595,203,58,0.2857142857142857,0.2083333333333333,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,2,STYLE,0.0374316153181687,DLS_DEAD_LOCAL_STORE,17,2,1,0.002218524681087,0.0005546311702717693,0.00027731558513588466,-1.0,0.1030927835051546,0.0024990449052517,0.1389114541023558,0.3314796054467413,-0.7835051546391752,0.0,0.0660741885625966,0.3314796054467413,-0.3333333333333333,-1.0,21,6296,681,14154,22,0.0293885823668505,0,14,8,36,0.0092396762715365,0,0,0,0,8,0,13,0.0,21,0,0,0,0,5,0,0,0.0,365,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,0,0,8177,26424,365,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/WFSTCompletionLookup.java,build,8177,open,"@Override
  public void build(InputIterator iterator) throws IOException {
    if (iterator.hasPayloads()) {
      throw new IllegalArgumentException(""this suggester doesn't support payloads"");
    }
    BytesRef scratch = new BytesRef();
    InputIterator iter = new WFSTInputIterator(iterator);
    IntsRef scratchInts = new IntsRef();
    BytesRef previous = null;
    PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();
    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, outputs);
    while ((scratch = iter.next()) != null) {
      long cost = iter.weight();
      
      if (previous == null) {
        previous = new BytesRef();
      } else if (scratch.equals(previous)) {
        continue; // for duplicate suggestions, the best weight is actually
                  // added
      }
      Util.toIntsRef(scratch, scratchInts);
      builder.add(scratchInts, cost);
      previous.copyBytes(scratch);
    }
    fst = builder.finish();
  }"
lucene-solr-C-1802,9050,org/apache/solr/core,org/apache/solr/core/HdfsDirectoryFactory.java,188,True,44,11,5445,1,5,574,6,80,0.3472222222222222,232,18,0.0775862068965517,0.1022727272727272,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,5,MT_CORRECTNESS,0.0020155485171321,LI_LAZY_INIT_STATIC,14,2,1,0.0266222961730449,0.0013865779256794,0.00027731558513588466,0.0,1.0,0.0,0.2467532467532467,0.4240059211270735,1.0,0.0,0.0073415765069551,0.4240059211270735,-0.6486486486486487,0.0,0,1192,188,9050,187,0.0,39,174,13,400,0.0573815976686728,0,0,0,0,0,0,0,0.0,0,0,0,0,0,0,0,0,0.0,1238,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,9050,2910,36,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//solr/core/src/java/org/apache/solr/core/HdfsDirectoryFactory.java,create,7848,open,"@Override
  protected Directory create(String path, DirContext dirContext)
      throws IOException {
    LOG.info(""creating directory factory for path {}"", path);
    Configuration conf = getConf();
    
    if (metrics == null) {
      metrics = new Metrics(conf);
    }
    
    boolean blockCacheEnabled = params.getBool(BLOCKCACHE_ENABLED, true);
    boolean blockCacheReadEnabled = params.getBool(BLOCKCACHE_READ_ENABLED,
        true);
    boolean blockCacheWriteEnabled = params.getBool(BLOCKCACHE_WRITE_ENABLED, true);
    Directory dir = null;
    
    if (blockCacheEnabled && dirContext != DirContext.META_DATA) {
      int numberOfBlocksPerBank = params.getInt(NUMBEROFBLOCKSPERBANK, 16384);
      
      int blockSize = BlockDirectory.BLOCK_SIZE;
      
      int bankCount = params.getInt(BLOCKCACHE_SLAB_COUNT, 1);
      
      boolean directAllocation = params.getBool(
          BLOCKCACHE_DIRECT_MEMORY_ALLOCATION, true);
      
      BlockCache blockCache;
      
      int slabSize = numberOfBlocksPerBank * blockSize;
      LOG.info(
          ""Number of slabs of block cache [{}] with direct memory allocation set to [{}]"",
          bankCount, directAllocation);
      LOG.info(
          ""Block cache target memory usage, slab size of [{}] will allocate [{}] slabs and use ~[{}] bytes"",
          new Object[] {slabSize, bankCount,
              ((long) bankCount * (long) slabSize)});
      
      int _1024Size = params.getInt(""solr.hdfs.blockcache.bufferstore.1024"",
          8192);
      int _8192Size = params.getInt(""solr.hdfs.blockcache.bufferstore.8192"",
          8192);
      
      BufferStore.init(_1024Size, _8192Size, metrics);
      long totalMemory = (long) bankCount * (long) numberOfBlocksPerBank
          * (long) blockSize;
      try {
        blockCache = new BlockCache(metrics, directAllocation, totalMemory,
            slabSize, blockSize);
      } catch (OutOfMemoryError e) {
        throw new RuntimeException(
            ""The max direct memory is likely too low.  Either increase it (by adding -XX:MaxDirectMemorySize=<size>g -XX:+UseLargePages to your containers startup args)""
                + "" or disable direct allocation using solr.hdfs.blockcache.direct.memory.allocation=false in solrconfig.xml. If you are putting the block cache on the heap,""
                + "" your java heap size might not be large enough.""
                + "" Failed allocating ~"" + totalMemory / 1000000.0 + "" MB."", e);
      }
      Cache cache = new BlockDirectoryCache(blockCache, metrics);
      HdfsDirectory hdfsDirectory = new HdfsDirectory(new Path(path), conf);
      dir = new BlockDirectory(""solrcore"", hdfsDirectory, cache, null,
          blockCacheReadEnabled, blockCacheWriteEnabled);
    } else {
      dir = new HdfsDirectory(new Path(path), conf);
    }
    
    boolean nrtCachingDirectory = params.getBool(NRTCACHINGDIRECTORY_ENABLE, true);
    if (nrtCachingDirectory) {
      double nrtCacheMaxMergeSizeMB = params.getInt(
          NRTCACHINGDIRECTORY_MAXMERGESIZEMB, 16);
      double nrtCacheMaxCacheMB = params.getInt(NRTCACHINGDIRECTORY_MAXCACHEMB,
          192);
      
      return new NRTCachingDirectory(dir, nrtCacheMaxMergeSizeMB,
          nrtCacheMaxCacheMB);
    }
    return dir;
  }"
lucene-solr-C-2205,19129,org/apache/solr/schema,org/apache/solr/schema/GeoHashField.java,1463,True,11,6,6566,1,4,585,1,141,0.5727272727272728,63,29,0.4603174603174603,0.1818181818181818,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,70,2,STYLE,0.0374316153181687,DLS_DEAD_LOCAL_STORE,17,2,1,0.0194120909595119,0.0005546311702717693,0.00027731558513588466,-1.0,0.1030927835051546,0.0024990449052517,0.1389114541023558,0.3314796054467413,-0.7835051546391752,0.0,0.0660741885625966,0.3314796054467413,-0.6785714285714286,-1.0,16,10433,1271,18291,625,0.0,50,52,573,727,0.0179259899619019,0,0,0,0,0,0,0,0.0,0,0,0,0,0,0,0,0,0.0,2991,1,0,1,0,0,0,0,1,1,0,0,0,0,0,1,1,1,0,0,1,10803,15833,69,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//solr/core/src/java/org/apache/solr/schema/GeoHashField.java,createSpatialQuery,7881,close,"@Override
  public Query createSpatialQuery(QParser parser, SpatialOptions options) {
    double [] point = new double[0];
    try {
      point = ParseUtils.parsePointDouble(null, options.pointStr, 2);
    } catch (InvalidShapeException e) {
      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);
    }
    String geohash = GeohashUtils.encodeLatLon(point[0], point[1]);
    //TODO: optimize this
    return new SolrConstantScoreQuery(new ValueSourceRangeFilter(new GeohashHaversineFunction(getValueSource(options.field, parser),
            new LiteralValueSource(geohash), options.radius), ""0"", String.valueOf(options.distance), true, true));
  }"
lucene-solr-C-2348,10509,org/apache/solr/search,org/apache/solr/search/SolrReturnFields.java,358,True,2,15,8673,1,0,569,1,275,0.7534246575342466,320,61,0.190625,1.0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,190,4,STYLE,0.0296573567520875,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,18,2,4,0.052689961175818,0.0011092623405435,0.0011092623405435,0.0,0.1686746987951807,0.0037898255346361,0.1389114541023558,0.3314796054467413,-0.6265060240963856,0.0,0.0660741885625966,0.3314796054467413,-0.6932515337423313,0.0,1,2651,358,10509,430,0.0,10,34,396,474,0.0176769365871945,0,0,0,0,0,0,0,0.0,0,130,0,2,9,0,141,128,0.0078570505642174,1624,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9436,26424,2,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//solr/core/src/java/org/apache/solr/search/SolrReturnFields.java,add,7814,close,"private void add(String fl, NamedList<String> rename, DocTransformers augmenters, SolrQueryRequest req) {
    if( fl == null ) {
      return;
    }
    try {
      QueryParsing.StrParser sp = new QueryParsing.StrParser(fl);

      for(;;) {
        sp.opt(',');
        sp.eatws();
        if (sp.pos >= sp.end) break;

        int start = sp.pos;

        // short circuit test for a really simple field name
        String key = null;
        String field = getFieldName(sp);
        char ch = sp.ch();

        if (field != null) {
          if (sp.opt(':')) {
            // this was a key, not a field name
            key = field;
            field = null;
            sp.eatws();
            start = sp.pos;
          } else {
            if (Character.isWhitespace(ch) || ch == ',' || ch==0) {
              addField( field, key, augmenters, req );
              continue;
            }
            // an invalid field name... reset the position pointer to retry
            sp.pos = start;
            field = null;
          }
        }

        if (key != null) {
          // we read ""key : ""
          field = sp.getId(null);
          ch = sp.ch();
          if (field != null && (Character.isWhitespace(ch) || ch == ',' || ch==0)) {
            rename.add(field, key);
            addField( field, key, augmenters, req );
            continue;
          }
          // an invalid field name... reset the position pointer to retry
          sp.pos = start;
          field = null;
        }

        if (field == null) {
          // We didn't find a simple name, so let's see if it's a globbed field name.
          // Globbing only works with field names of the recommended form (roughly like java identifiers)

          field = sp.getGlobbedId(null);
          ch = sp.ch();
          if (field != null && (Character.isWhitespace(ch) || ch == ',' || ch==0)) {
            // ""*"" looks and acts like a glob, but we give it special treatment
            if (""*"".equals(field)) {
              _wantsAllFields = true;
            } else {
              globs.add(field);
            }
            continue;
          }

          // an invalid glob
          sp.pos = start;
        }

        String funcStr = sp.val.substring(start);

        // Is it an augmenter of the form [augmenter_name foo=1 bar=myfield]?
        // This is identical to localParams syntax except it uses [] instead of {!}

        if (funcStr.startsWith(""["")) {
          Map<String,String> augmenterArgs = new HashMap<String,String>();
          int end = QueryParsing.parseLocalParams(funcStr, 0, augmenterArgs, req.getParams(), ""["", ']');
          sp.pos += end;

          // [foo] is short for [type=foo] in localParams syntax
          String augmenterName = augmenterArgs.remove(""type"");
          String disp = key;
          if( disp == null ) {
            disp = '['+augmenterName+']';
          }

          TransformerFactory factory = req.getCore().getTransformerFactory( augmenterName );
          if( factory != null ) {
            MapSolrParams augmenterParams = new MapSolrParams( augmenterArgs );
            augmenters.addTransformer( factory.create(disp, augmenterParams, req) );
          }
          else {
            // unknown transformer?
          }
          addField(field, disp, augmenters, req);
          continue;
        }


        // let's try it as a function instead
        QParser parser = QParser.getParser(funcStr, FunctionQParserPlugin.NAME, req);
        Query q = null;
        ValueSource vs = null;

        try {
          if (parser instanceof FunctionQParser) {
            FunctionQParser fparser = (FunctionQParser)parser;
            fparser.setParseMultipleSources(false);
            fparser.setParseToEnd(false);

            q = fparser.getQuery();

            if (fparser.localParams != null) {
              if (fparser.valFollowedParams) {
                // need to find the end of the function query via the string parser
                int leftOver = fparser.sp.end - fparser.sp.pos;
                sp.pos = sp.end - leftOver;   // reset our parser to the same amount of leftover
              } else {
                // the value was via the ""v"" param in localParams, so we need to find
                // the end of the local params themselves to pick up where we left off
                sp.pos = start + fparser.localParamsEnd;
              }
            } else {
              // need to find the end of the function query via the string parser
              int leftOver = fparser.sp.end - fparser.sp.pos;
              sp.pos = sp.end - leftOver;   // reset our parser to the same amount of leftover
            }
          } else {
            // A QParser that's not for function queries.
            // It must have been specified via local params.
            q = parser.getQuery();

            assert parser.getLocalParams() != null;
            sp.pos = start + parser.localParamsEnd;
          }


          if (q instanceof FunctionQuery) {
            vs = ((FunctionQuery)q).getValueSource();
          } else {
            vs = new QueryValueSource(q, 0.0f);
          }

          if (key==null) {
            SolrParams localParams = parser.getLocalParams();
            if (localParams != null) {
              key = localParams.get(""key"");
            }
            if (key == null) {
              // use the function name itself as the field name
              key = sp.val.substring(start, sp.pos);
            }
          }


          if (key==null) {
            key = funcStr;
          }
          okFieldNames.add( key );
          okFieldNames.add( funcStr );
          augmenters.addTransformer( new ValueSourceAugmenter( key, parser, vs ) );
        }
        catch (SyntaxError e) {
          // try again, simple rules for a field name with no whitespace
          sp.pos = start;
          field = sp.getSimpleString();

          if (req.getSchema().getFieldOrNull(field) != null) {
            // OK, it was an oddly named field
            fields.add(field);
            if( key != null ) {
              rename.add(field, key);
            }
          } else {
            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, ""Error parsing fieldname: "" + e.getMessage(), e);
          }
        }

        // end try as function

      } // end for(;;)
    } catch (SyntaxError e) {
      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, ""Error parsing fieldname"", e);
    }
  }"
lucene-solr-C-2349,10509,org/apache/solr/search,org/apache/solr/search/SolrReturnFields.java,358,True,2,15,8673,1,0,569,1,275,0.5114155251141552,320,61,0.190625,1.0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,190,4,STYLE,0.0037431615318168,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,20,3,4,0.052689961175818,0.0011092623405435,0.0011092623405435,0.0,0.125,0.002956081081081,0.1389114541023558,0.3314796054467413,-0.75,0.0,0.0660741885625966,0.3314796054467413,-0.6932515337423313,0.0,1,2651,358,10509,430,0.0,10,34,396,474,0.0176769365871945,0,0,0,0,0,0,0,0.0,0,130,0,2,9,0,141,128,0.0078570505642174,1624,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9436,26424,2,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//solr/core/src/java/org/apache/solr/search/SolrReturnFields.java,add,7814,open,"private void add(String fl, NamedList<String> rename, DocTransformers augmenters, SolrQueryRequest req) {
    if( fl == null ) {
      return;
    }
    try {
      QueryParsing.StrParser sp = new QueryParsing.StrParser(fl);

      for(;;) {
        sp.opt(',');
        sp.eatws();
        if (sp.pos >= sp.end) break;

        int start = sp.pos;

        // short circuit test for a really simple field name
        String key = null;
        String field = getFieldName(sp);
        char ch = sp.ch();

        if (field != null) {
          if (sp.opt(':')) {
            // this was a key, not a field name
            key = field;
            field = null;
            sp.eatws();
            start = sp.pos;
          } else {
            if (Character.isWhitespace(ch) || ch == ',' || ch==0) {
              addField( field, key, augmenters, req );
              continue;
            }
            // an invalid field name... reset the position pointer to retry
            sp.pos = start;
            field = null;
          }
        }

        if (key != null) {
          // we read ""key : ""
          field = sp.getId(null);
          ch = sp.ch();
          if (field != null && (Character.isWhitespace(ch) || ch == ',' || ch==0)) {
            rename.add(field, key);
            addField( field, key, augmenters, req );
            continue;
          }
          // an invalid field name... reset the position pointer to retry
          sp.pos = start;
          field = null;
        }

        if (field == null) {
          // We didn't find a simple name, so let's see if it's a globbed field name.
          // Globbing only works with field names of the recommended form (roughly like java identifiers)

          field = sp.getGlobbedId(null);
          ch = sp.ch();
          if (field != null && (Character.isWhitespace(ch) || ch == ',' || ch==0)) {
            // ""*"" looks and acts like a glob, but we give it special treatment
            if (""*"".equals(field)) {
              _wantsAllFields = true;
            } else {
              globs.add(field);
            }
            continue;
          }

          // an invalid glob
          sp.pos = start;
        }

        String funcStr = sp.val.substring(start);

        // Is it an augmenter of the form [augmenter_name foo=1 bar=myfield]?
        // This is identical to localParams syntax except it uses [] instead of {!}

        if (funcStr.startsWith(""["")) {
          Map<String,String> augmenterArgs = new HashMap<String,String>();
          int end = QueryParsing.parseLocalParams(funcStr, 0, augmenterArgs, req.getParams(), ""["", ']');
          sp.pos += end;

          // [foo] is short for [type=foo] in localParams syntax
          String augmenterName = augmenterArgs.remove(""type"");
          String disp = key;
          if( disp == null ) {
            disp = '['+augmenterName+']';
          }

          TransformerFactory factory = req.getCore().getTransformerFactory( augmenterName );
          if( factory != null ) {
            MapSolrParams augmenterParams = new MapSolrParams( augmenterArgs );
            augmenters.addTransformer( factory.create(disp, augmenterParams, req) );
          }
          else {
            // unknown transformer?
          }
          addField(field, disp, augmenters, req);
          continue;
        }


        // let's try it as a function instead
        QParser parser = QParser.getParser(funcStr, FunctionQParserPlugin.NAME, req);
        Query q = null;
        ValueSource vs = null;

        try {
          if (parser instanceof FunctionQParser) {
            FunctionQParser fparser = (FunctionQParser)parser;
            fparser.setParseMultipleSources(false);
            fparser.setParseToEnd(false);

            q = fparser.getQuery();

            if (fparser.localParams != null) {
              if (fparser.valFollowedParams) {
                // need to find the end of the function query via the string parser
                int leftOver = fparser.sp.end - fparser.sp.pos;
                sp.pos = sp.end - leftOver;   // reset our parser to the same amount of leftover
              } else {
                // the value was via the ""v"" param in localParams, so we need to find
                // the end of the local params themselves to pick up where we left off
                sp.pos = start + fparser.localParamsEnd;
              }
            } else {
              // need to find the end of the function query via the string parser
              int leftOver = fparser.sp.end - fparser.sp.pos;
              sp.pos = sp.end - leftOver;   // reset our parser to the same amount of leftover
            }
          } else {
            // A QParser that's not for function queries.
            // It must have been specified via local params.
            q = parser.getQuery();

            assert parser.getLocalParams() != null;
            sp.pos = start + parser.localParamsEnd;
          }


          if (q instanceof FunctionQuery) {
            vs = ((FunctionQuery)q).getValueSource();
          } else {
            vs = new QueryValueSource(q, 0.0f);
          }

          if (key==null) {
            SolrParams localParams = parser.getLocalParams();
            if (localParams != null) {
              key = localParams.get(""key"");
            }
            if (key == null) {
              // use the function name itself as the field name
              key = sp.val.substring(start, sp.pos);
            }
          }


          if (key==null) {
            key = funcStr;
          }
          okFieldNames.add( key );
          okFieldNames.add( funcStr );
          augmenters.addTransformer( new ValueSourceAugmenter( key, parser, vs ) );
        }
        catch (SyntaxError e) {
          // try again, simple rules for a field name with no whitespace
          sp.pos = start;
          field = sp.getSimpleString();

          if (req.getSchema().getFieldOrNull(field) != null) {
            // OK, it was an oddly named field
            fields.add(field);
            if( key != null ) {
              rename.add(field, key);
            }
          } else {
            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, ""Error parsing fieldname: "" + e.getMessage(), e);
          }
        }

        // end try as function

      } // end for(;;)
    } catch (SyntaxError e) {
      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, ""Error parsing fieldname"", e);
    }
  }"
